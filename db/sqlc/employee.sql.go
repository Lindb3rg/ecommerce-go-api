// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: employee.sql

package db

import (
	"context"
	"database/sql"
)

const countEmployees = `-- name: CountEmployees :one
SELECT COUNT(*) FROM employees
`

// Counts the total number of employees
func (q *Queries) CountEmployees(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEmployees)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEmployeesByManager = `-- name: CountEmployeesByManager :many
SELECT 
  m.employee_id,
  m.last_name,
  m.first_name,
  COUNT(e.employee_id) as direct_reports
FROM employees m
LEFT JOIN employees e ON m.employee_id = e.reports_to
GROUP BY m.employee_id, m.last_name, m.first_name
ORDER BY COUNT(e.employee_id) DESC
`

type CountEmployeesByManagerRow struct {
	EmployeeID    int16  `json:"employee_id"`
	LastName      string `json:"last_name"`
	FirstName     string `json:"first_name"`
	DirectReports int64  `json:"direct_reports"`
}

// Counts direct reports for each manager
func (q *Queries) CountEmployeesByManager(ctx context.Context) ([]CountEmployeesByManagerRow, error) {
	rows, err := q.db.QueryContext(ctx, countEmployeesByManager)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountEmployeesByManagerRow{}
	for rows.Next() {
		var i CountEmployeesByManagerRow
		if err := rows.Scan(
			&i.EmployeeID,
			&i.LastName,
			&i.FirstName,
			&i.DirectReports,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (
  last_name,
  first_name,
  title,
  title_of_courtesy,
  birth_date,
  hire_date,
  address,
  city,
  region,
  postal_code,
  country,
  home_phone,
  extension,
  photo,
  notes,
  reports_to,
  photo_path
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING employee_id, last_name, first_name, title, title_of_courtesy, birth_date, hire_date, address, city, region, postal_code, country, home_phone, extension, photo, notes, reports_to, photo_path
`

type CreateEmployeeParams struct {
	LastName        string         `json:"last_name"`
	FirstName       string         `json:"first_name"`
	Title           sql.NullString `json:"title"`
	TitleOfCourtesy sql.NullString `json:"title_of_courtesy"`
	BirthDate       sql.NullTime   `json:"birth_date"`
	HireDate        sql.NullTime   `json:"hire_date"`
	Address         sql.NullString `json:"address"`
	City            sql.NullString `json:"city"`
	Region          sql.NullString `json:"region"`
	PostalCode      sql.NullString `json:"postal_code"`
	Country         sql.NullString `json:"country"`
	HomePhone       sql.NullString `json:"home_phone"`
	Extension       sql.NullString `json:"extension"`
	Photo           []byte         `json:"photo"`
	Notes           sql.NullString `json:"notes"`
	ReportsTo       sql.NullInt16  `json:"reports_to"`
	PhotoPath       sql.NullString `json:"photo_path"`
}

// Creates a new employee and returns it
func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, createEmployee,
		arg.LastName,
		arg.FirstName,
		arg.Title,
		arg.TitleOfCourtesy,
		arg.BirthDate,
		arg.HireDate,
		arg.Address,
		arg.City,
		arg.Region,
		arg.PostalCode,
		arg.Country,
		arg.HomePhone,
		arg.Extension,
		arg.Photo,
		arg.Notes,
		arg.ReportsTo,
		arg.PhotoPath,
	)
	var i Employee
	err := row.Scan(
		&i.EmployeeID,
		&i.LastName,
		&i.FirstName,
		&i.Title,
		&i.TitleOfCourtesy,
		&i.BirthDate,
		&i.HireDate,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.HomePhone,
		&i.Extension,
		&i.Photo,
		&i.Notes,
		&i.ReportsTo,
		&i.PhotoPath,
	)
	return i, err
}

const deleteEmployee = `-- name: DeleteEmployee :exec
DELETE FROM employees
WHERE employee_id = $1
`

// Deletes an employee by ID
func (q *Queries) DeleteEmployee(ctx context.Context, employeeID int16) error {
	_, err := q.db.ExecContext(ctx, deleteEmployee, employeeID)
	return err
}

const getEmployee = `-- name: GetEmployee :one
SELECT employee_id, last_name, first_name, title, title_of_courtesy, birth_date, hire_date, address, city, region, postal_code, country, home_phone, extension, photo, notes, reports_to, photo_path
FROM employees
WHERE employee_id = $1
`

// Gets an employee by ID
func (q *Queries) GetEmployee(ctx context.Context, employeeID int16) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getEmployee, employeeID)
	var i Employee
	err := row.Scan(
		&i.EmployeeID,
		&i.LastName,
		&i.FirstName,
		&i.Title,
		&i.TitleOfCourtesy,
		&i.BirthDate,
		&i.HireDate,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.HomePhone,
		&i.Extension,
		&i.Photo,
		&i.Notes,
		&i.ReportsTo,
		&i.PhotoPath,
	)
	return i, err
}

const getEmployeeHierarchy = `-- name: GetEmployeeHierarchy :many
WITH RECURSIVE emp_hierarchy AS (
  SELECT 
    e.employee_id, 
    e.last_name, 
    e.first_name, 
    e.title, 
    e.reports_to, 
    0 as level
  FROM employees e
  WHERE e.employee_id = $1
  
  UNION ALL
  
  SELECT 
    e.employee_id, 
    e.last_name, 
    e.first_name, 
    e.title, 
    e.reports_to, 
    eh.level + 1
  FROM employees e
  JOIN emp_hierarchy eh ON e.reports_to = eh.employee_id
)
SELECT 
  employee_id,
  last_name,
  first_name,
  title,
  reports_to,
  level
FROM emp_hierarchy
ORDER BY level
`

type GetEmployeeHierarchyRow struct {
	EmployeeID int16          `json:"employee_id"`
	LastName   string         `json:"last_name"`
	FirstName  string         `json:"first_name"`
	Title      sql.NullString `json:"title"`
	ReportsTo  sql.NullInt16  `json:"reports_to"`
	Level      int32          `json:"level"`
}

// Gets the entire reporting hierarchy for an employee
func (q *Queries) GetEmployeeHierarchy(ctx context.Context, employeeID int16) ([]GetEmployeeHierarchyRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeHierarchy, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEmployeeHierarchyRow{}
	for rows.Next() {
		var i GetEmployeeHierarchyRow
		if err := rows.Scan(
			&i.EmployeeID,
			&i.LastName,
			&i.FirstName,
			&i.Title,
			&i.ReportsTo,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeWithManager = `-- name: GetEmployeeWithManager :one
SELECT 
  e.employee_id,
  e.last_name,
  e.first_name,
  e.title,
  e.title_of_courtesy,
  e.birth_date,
  e.hire_date,
  e.address,
  e.city,
  e.region,
  e.postal_code,
  e.country,
  e.home_phone,
  e.extension,
  e.photo,
  e.notes,
  e.reports_to,
  e.photo_path,
  m.employee_id as manager_id,
  m.last_name as manager_last_name,
  m.first_name as manager_first_name,
  m.title as manager_title
FROM employees e
LEFT JOIN employees m ON e.reports_to = m.employee_id
WHERE e.employee_id = $1
`

type GetEmployeeWithManagerRow struct {
	EmployeeID       int16          `json:"employee_id"`
	LastName         string         `json:"last_name"`
	FirstName        string         `json:"first_name"`
	Title            sql.NullString `json:"title"`
	TitleOfCourtesy  sql.NullString `json:"title_of_courtesy"`
	BirthDate        sql.NullTime   `json:"birth_date"`
	HireDate         sql.NullTime   `json:"hire_date"`
	Address          sql.NullString `json:"address"`
	City             sql.NullString `json:"city"`
	Region           sql.NullString `json:"region"`
	PostalCode       sql.NullString `json:"postal_code"`
	Country          sql.NullString `json:"country"`
	HomePhone        sql.NullString `json:"home_phone"`
	Extension        sql.NullString `json:"extension"`
	Photo            []byte         `json:"photo"`
	Notes            sql.NullString `json:"notes"`
	ReportsTo        sql.NullInt16  `json:"reports_to"`
	PhotoPath        sql.NullString `json:"photo_path"`
	ManagerID        sql.NullInt16  `json:"manager_id"`
	ManagerLastName  sql.NullString `json:"manager_last_name"`
	ManagerFirstName sql.NullString `json:"manager_first_name"`
	ManagerTitle     sql.NullString `json:"manager_title"`
}

// Gets an employee by ID along with their manager's details
func (q *Queries) GetEmployeeWithManager(ctx context.Context, employeeID int16) (GetEmployeeWithManagerRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeWithManager, employeeID)
	var i GetEmployeeWithManagerRow
	err := row.Scan(
		&i.EmployeeID,
		&i.LastName,
		&i.FirstName,
		&i.Title,
		&i.TitleOfCourtesy,
		&i.BirthDate,
		&i.HireDate,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.HomePhone,
		&i.Extension,
		&i.Photo,
		&i.Notes,
		&i.ReportsTo,
		&i.PhotoPath,
		&i.ManagerID,
		&i.ManagerLastName,
		&i.ManagerFirstName,
		&i.ManagerTitle,
	)
	return i, err
}

const listEmployees = `-- name: ListEmployees :many
SELECT employee_id, last_name, first_name, title, title_of_courtesy, birth_date, hire_date, address, city, region, postal_code, country, home_phone, extension, photo, notes, reports_to, photo_path
FROM employees
ORDER BY last_name, first_name
`

// Lists all employees
func (q *Queries) ListEmployees(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listEmployees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmployeeID,
			&i.LastName,
			&i.FirstName,
			&i.Title,
			&i.TitleOfCourtesy,
			&i.BirthDate,
			&i.HireDate,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.HomePhone,
			&i.Extension,
			&i.Photo,
			&i.Notes,
			&i.ReportsTo,
			&i.PhotoPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesByCountry = `-- name: ListEmployeesByCountry :many
SELECT employee_id, last_name, first_name, title, title_of_courtesy, birth_date, hire_date, address, city, region, postal_code, country, home_phone, extension, photo, notes, reports_to, photo_path
FROM employees
WHERE country = $1
ORDER BY last_name, first_name
`

// Lists all employees from a specific country
func (q *Queries) ListEmployeesByCountry(ctx context.Context, country sql.NullString) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listEmployeesByCountry, country)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmployeeID,
			&i.LastName,
			&i.FirstName,
			&i.Title,
			&i.TitleOfCourtesy,
			&i.BirthDate,
			&i.HireDate,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.HomePhone,
			&i.Extension,
			&i.Photo,
			&i.Notes,
			&i.ReportsTo,
			&i.PhotoPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesByManager = `-- name: ListEmployeesByManager :many
SELECT employee_id, last_name, first_name, title, title_of_courtesy, birth_date, hire_date, address, city, region, postal_code, country, home_phone, extension, photo, notes, reports_to, photo_path
FROM employees
WHERE reports_to = $1
ORDER BY last_name, first_name
`

// Lists all employees that report to a specific manager
func (q *Queries) ListEmployeesByManager(ctx context.Context, reportsTo sql.NullInt16) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listEmployeesByManager, reportsTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmployeeID,
			&i.LastName,
			&i.FirstName,
			&i.Title,
			&i.TitleOfCourtesy,
			&i.BirthDate,
			&i.HireDate,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.HomePhone,
			&i.Extension,
			&i.Photo,
			&i.Notes,
			&i.ReportsTo,
			&i.PhotoPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesByTitle = `-- name: ListEmployeesByTitle :many
SELECT employee_id, last_name, first_name, title, title_of_courtesy, birth_date, hire_date, address, city, region, postal_code, country, home_phone, extension, photo, notes, reports_to, photo_path
FROM employees
WHERE title = $1
ORDER BY last_name, first_name
`

// Lists all employees with a specific title
func (q *Queries) ListEmployeesByTitle(ctx context.Context, title sql.NullString) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listEmployeesByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmployeeID,
			&i.LastName,
			&i.FirstName,
			&i.Title,
			&i.TitleOfCourtesy,
			&i.BirthDate,
			&i.HireDate,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.HomePhone,
			&i.Extension,
			&i.Photo,
			&i.Notes,
			&i.ReportsTo,
			&i.PhotoPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEmployeesByName = `-- name: SearchEmployeesByName :many
SELECT employee_id, last_name, first_name, title, title_of_courtesy, birth_date, hire_date, address, city, region, postal_code, country, home_phone, extension, photo, notes, reports_to, photo_path
FROM employees
WHERE first_name ILIKE '%' || $1 || '%' OR last_name ILIKE '%' || $1 || '%'
ORDER BY last_name, first_name
`

// Searches employees by first or last name (case insensitive)
func (q *Queries) SearchEmployeesByName(ctx context.Context, dollar_1 sql.NullString) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, searchEmployeesByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmployeeID,
			&i.LastName,
			&i.FirstName,
			&i.Title,
			&i.TitleOfCourtesy,
			&i.BirthDate,
			&i.HireDate,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.HomePhone,
			&i.Extension,
			&i.Photo,
			&i.Notes,
			&i.ReportsTo,
			&i.PhotoPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE employees
SET
  last_name = $2,
  first_name = $3,
  title = $4,
  title_of_courtesy = $5,
  birth_date = $6,
  hire_date = $7,
  address = $8,
  city = $9,
  region = $10,
  postal_code = $11,
  country = $12,
  home_phone = $13,
  extension = $14,
  photo = $15,
  notes = $16,
  reports_to = $17,
  photo_path = $18
WHERE employee_id = $1
RETURNING employee_id, last_name, first_name, title, title_of_courtesy, birth_date, hire_date, address, city, region, postal_code, country, home_phone, extension, photo, notes, reports_to, photo_path
`

type UpdateEmployeeParams struct {
	EmployeeID      int16          `json:"employee_id"`
	LastName        string         `json:"last_name"`
	FirstName       string         `json:"first_name"`
	Title           sql.NullString `json:"title"`
	TitleOfCourtesy sql.NullString `json:"title_of_courtesy"`
	BirthDate       sql.NullTime   `json:"birth_date"`
	HireDate        sql.NullTime   `json:"hire_date"`
	Address         sql.NullString `json:"address"`
	City            sql.NullString `json:"city"`
	Region          sql.NullString `json:"region"`
	PostalCode      sql.NullString `json:"postal_code"`
	Country         sql.NullString `json:"country"`
	HomePhone       sql.NullString `json:"home_phone"`
	Extension       sql.NullString `json:"extension"`
	Photo           []byte         `json:"photo"`
	Notes           sql.NullString `json:"notes"`
	ReportsTo       sql.NullInt16  `json:"reports_to"`
	PhotoPath       sql.NullString `json:"photo_path"`
}

// Updates an employee by ID
func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, updateEmployee,
		arg.EmployeeID,
		arg.LastName,
		arg.FirstName,
		arg.Title,
		arg.TitleOfCourtesy,
		arg.BirthDate,
		arg.HireDate,
		arg.Address,
		arg.City,
		arg.Region,
		arg.PostalCode,
		arg.Country,
		arg.HomePhone,
		arg.Extension,
		arg.Photo,
		arg.Notes,
		arg.ReportsTo,
		arg.PhotoPath,
	)
	var i Employee
	err := row.Scan(
		&i.EmployeeID,
		&i.LastName,
		&i.FirstName,
		&i.Title,
		&i.TitleOfCourtesy,
		&i.BirthDate,
		&i.HireDate,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.HomePhone,
		&i.Extension,
		&i.Photo,
		&i.Notes,
		&i.ReportsTo,
		&i.PhotoPath,
	)
	return i, err
}
