// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: territory.sql

package db

import (
	"context"
	"database/sql"
)

const countTerritories = `-- name: CountTerritories :one
SELECT COUNT(*) FROM territories
`

// Counts the total number of territories
func (q *Queries) CountTerritories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTerritories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTerritoriesByRegion = `-- name: CountTerritoriesByRegion :many
SELECT 
  r.region_id,
  r.region_description,
  COUNT(*) as territory_count
FROM territories t
JOIN region r ON t.region_id = r.region_id
GROUP BY r.region_id, r.region_description
ORDER BY COUNT(*) DESC
`

type CountTerritoriesByRegionRow struct {
	RegionID          int16       `json:"region_id"`
	RegionDescription interface{} `json:"region_description"`
	TerritoryCount    int64       `json:"territory_count"`
}

// Counts territories grouped by region
func (q *Queries) CountTerritoriesByRegion(ctx context.Context) ([]CountTerritoriesByRegionRow, error) {
	rows, err := q.db.QueryContext(ctx, countTerritoriesByRegion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountTerritoriesByRegionRow{}
	for rows.Next() {
		var i CountTerritoriesByRegionRow
		if err := rows.Scan(&i.RegionID, &i.RegionDescription, &i.TerritoryCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createTerritory = `-- name: CreateTerritory :one
INSERT INTO territories (
  territory_id,
  territory_description,
  region_id
) VALUES (
  $1, $2, $3
)
RETURNING territory_id, territory_description, region_id
`

type CreateTerritoryParams struct {
	TerritoryID          string      `json:"territory_id"`
	TerritoryDescription interface{} `json:"territory_description"`
	RegionID             int16       `json:"region_id"`
}

// Creates a new territory and returns it
func (q *Queries) CreateTerritory(ctx context.Context, arg CreateTerritoryParams) (Territory, error) {
	row := q.db.QueryRowContext(ctx, createTerritory, arg.TerritoryID, arg.TerritoryDescription, arg.RegionID)
	var i Territory
	err := row.Scan(&i.TerritoryID, &i.TerritoryDescription, &i.RegionID)
	return i, err
}

const deleteTerritory = `-- name: DeleteTerritory :exec
DELETE FROM territories
WHERE territory_id = $1
`

// Deletes a territory by ID
func (q *Queries) DeleteTerritory(ctx context.Context, territoryID string) error {
	_, err := q.db.ExecContext(ctx, deleteTerritory, territoryID)
	return err
}

const getTerritory = `-- name: GetTerritory :one
SELECT territory_id, territory_description, region_id
FROM territories
WHERE territory_id = $1
`

// Gets a territory by ID
func (q *Queries) GetTerritory(ctx context.Context, territoryID string) (Territory, error) {
	row := q.db.QueryRowContext(ctx, getTerritory, territoryID)
	var i Territory
	err := row.Scan(&i.TerritoryID, &i.TerritoryDescription, &i.RegionID)
	return i, err
}

const getTerritoryWithRegion = `-- name: GetTerritoryWithRegion :one
SELECT 
  t.territory_id,
  t.territory_description,
  t.region_id,
  r.region_description
FROM territories t
JOIN region r ON t.region_id = r.region_id
WHERE t.territory_id = $1
`

type GetTerritoryWithRegionRow struct {
	TerritoryID          string      `json:"territory_id"`
	TerritoryDescription interface{} `json:"territory_description"`
	RegionID             int16       `json:"region_id"`
	RegionDescription    interface{} `json:"region_description"`
}

// Gets a territory by ID with its region details
func (q *Queries) GetTerritoryWithRegion(ctx context.Context, territoryID string) (GetTerritoryWithRegionRow, error) {
	row := q.db.QueryRowContext(ctx, getTerritoryWithRegion, territoryID)
	var i GetTerritoryWithRegionRow
	err := row.Scan(
		&i.TerritoryID,
		&i.TerritoryDescription,
		&i.RegionID,
		&i.RegionDescription,
	)
	return i, err
}

const listTerritories = `-- name: ListTerritories :many
SELECT territory_id, territory_description, region_id
FROM territories
ORDER BY territory_id
`

// Lists all territories
func (q *Queries) ListTerritories(ctx context.Context) ([]Territory, error) {
	rows, err := q.db.QueryContext(ctx, listTerritories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Territory{}
	for rows.Next() {
		var i Territory
		if err := rows.Scan(&i.TerritoryID, &i.TerritoryDescription, &i.RegionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTerritoriesByRegion = `-- name: ListTerritoriesByRegion :many
SELECT territory_id, territory_description, region_id
FROM territories
WHERE region_id = $1
ORDER BY territory_id
`

// Lists all territories in a specific region
func (q *Queries) ListTerritoriesByRegion(ctx context.Context, regionID int16) ([]Territory, error) {
	rows, err := q.db.QueryContext(ctx, listTerritoriesByRegion, regionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Territory{}
	for rows.Next() {
		var i Territory
		if err := rows.Scan(&i.TerritoryID, &i.TerritoryDescription, &i.RegionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTerritoriesWithRegion = `-- name: ListTerritoriesWithRegion :many
SELECT 
  t.territory_id,
  t.territory_description,
  t.region_id,
  r.region_description
FROM territories t
JOIN region r ON t.region_id = r.region_id
ORDER BY t.territory_id
`

type ListTerritoriesWithRegionRow struct {
	TerritoryID          string      `json:"territory_id"`
	TerritoryDescription interface{} `json:"territory_description"`
	RegionID             int16       `json:"region_id"`
	RegionDescription    interface{} `json:"region_description"`
}

// Lists all territories with their region details
func (q *Queries) ListTerritoriesWithRegion(ctx context.Context) ([]ListTerritoriesWithRegionRow, error) {
	rows, err := q.db.QueryContext(ctx, listTerritoriesWithRegion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTerritoriesWithRegionRow{}
	for rows.Next() {
		var i ListTerritoriesWithRegionRow
		if err := rows.Scan(
			&i.TerritoryID,
			&i.TerritoryDescription,
			&i.RegionID,
			&i.RegionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTerritoriesByDescription = `-- name: SearchTerritoriesByDescription :many
SELECT territory_id, territory_description, region_id
FROM territories
WHERE territory_description ILIKE '%' || $1 || '%'
ORDER BY territory_id
`

// Searches territories by description (case insensitive)
func (q *Queries) SearchTerritoriesByDescription(ctx context.Context, dollar_1 sql.NullString) ([]Territory, error) {
	rows, err := q.db.QueryContext(ctx, searchTerritoriesByDescription, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Territory{}
	for rows.Next() {
		var i Territory
		if err := rows.Scan(&i.TerritoryID, &i.TerritoryDescription, &i.RegionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTerritory = `-- name: UpdateTerritory :one
UPDATE territories
SET
  territory_description = $2,
  region_id = $3
WHERE territory_id = $1
RETURNING territory_id, territory_description, region_id
`

type UpdateTerritoryParams struct {
	TerritoryID          string      `json:"territory_id"`
	TerritoryDescription interface{} `json:"territory_description"`
	RegionID             int16       `json:"region_id"`
}

// Updates a territory by ID
func (q *Queries) UpdateTerritory(ctx context.Context, arg UpdateTerritoryParams) (Territory, error) {
	row := q.db.QueryRowContext(ctx, updateTerritory, arg.TerritoryID, arg.TerritoryDescription, arg.RegionID)
	var i Territory
	err := row.Scan(&i.TerritoryID, &i.TerritoryDescription, &i.RegionID)
	return i, err
}
