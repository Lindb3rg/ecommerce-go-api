// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order.sql

package db

import (
	"context"
	"database/sql"
)

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*) FROM orders
`

// Counts the total number of orders
func (q *Queries) CountOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByCountry = `-- name: CountOrdersByCountry :many
SELECT 
  ship_country,
  COUNT(*) as order_count
FROM orders
GROUP BY ship_country
ORDER BY COUNT(*) DESC
`

type CountOrdersByCountryRow struct {
	ShipCountry sql.NullString `json:"ship_country"`
	OrderCount  int64          `json:"order_count"`
}

// Counts orders grouped by shipping country
func (q *Queries) CountOrdersByCountry(ctx context.Context) ([]CountOrdersByCountryRow, error) {
	rows, err := q.db.QueryContext(ctx, countOrdersByCountry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountOrdersByCountryRow{}
	for rows.Next() {
		var i CountOrdersByCountryRow
		if err := rows.Scan(&i.ShipCountry, &i.OrderCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countOrdersByStatus = `-- name: CountOrdersByStatus :many
SELECT
  CASE
    WHEN shipped_date IS NULL THEN 'Pending'
    WHEN shipped_date <= required_date THEN 'On Time'
    ELSE 'Delayed'
  END as status,
  COUNT(*) as order_count
FROM orders
GROUP BY status
ORDER BY status
`

type CountOrdersByStatusRow struct {
	Status     string `json:"status"`
	OrderCount int64  `json:"order_count"`
}

// Counts orders grouped by their status
func (q *Queries) CountOrdersByStatus(ctx context.Context) ([]CountOrdersByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, countOrdersByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountOrdersByStatusRow{}
	for rows.Next() {
		var i CountOrdersByStatusRow
		if err := rows.Scan(&i.Status, &i.OrderCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  customer_id,
  employee_id,
  order_date,
  required_date,
  shipped_date,
  ship_via,
  freight,
  ship_name,
  ship_address,
  ship_city,
  ship_region,
  ship_postal_code,
  ship_country
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
`

type CreateOrderParams struct {
	CustomerID     interface{}     `json:"customer_id"`
	EmployeeID     sql.NullInt16   `json:"employee_id"`
	OrderDate      sql.NullTime    `json:"order_date"`
	RequiredDate   sql.NullTime    `json:"required_date"`
	ShippedDate    sql.NullTime    `json:"shipped_date"`
	ShipVia        sql.NullInt16   `json:"ship_via"`
	Freight        sql.NullFloat64 `json:"freight"`
	ShipName       sql.NullString  `json:"ship_name"`
	ShipAddress    sql.NullString  `json:"ship_address"`
	ShipCity       sql.NullString  `json:"ship_city"`
	ShipRegion     sql.NullString  `json:"ship_region"`
	ShipPostalCode sql.NullString  `json:"ship_postal_code"`
	ShipCountry    sql.NullString  `json:"ship_country"`
}

// Creates a new order and returns it
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.CustomerID,
		arg.EmployeeID,
		arg.OrderDate,
		arg.RequiredDate,
		arg.ShippedDate,
		arg.ShipVia,
		arg.Freight,
		arg.ShipName,
		arg.ShipAddress,
		arg.ShipCity,
		arg.ShipRegion,
		arg.ShipPostalCode,
		arg.ShipCountry,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.OrderDate,
		&i.RequiredDate,
		&i.ShippedDate,
		&i.ShipVia,
		&i.Freight,
		&i.ShipName,
		&i.ShipAddress,
		&i.ShipCity,
		&i.ShipRegion,
		&i.ShipPostalCode,
		&i.ShipCountry,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders
WHERE order_id = $1
`

// Deletes an order by ID
func (q *Queries) DeleteOrder(ctx context.Context, orderID int16) error {
	_, err := q.db.ExecContext(ctx, deleteOrder, orderID)
	return err
}

const getAverageProcessingTime = `-- name: GetAverageProcessingTime :one
SELECT
  AVG(shipped_date - order_date) as avg_processing_days
FROM orders
WHERE shipped_date IS NOT NULL
`

// Gets the average time between order and shipment
func (q *Queries) GetAverageProcessingTime(ctx context.Context) (float64, error) {
	row := q.db.QueryRowContext(ctx, getAverageProcessingTime)
	var avg_processing_days float64
	err := row.Scan(&avg_processing_days)
	return avg_processing_days, err
}

const getMonthlyOrderCounts = `-- name: GetMonthlyOrderCounts :many
SELECT
  EXTRACT(MONTH FROM order_date) as month,
  COUNT(*) as order_count
FROM orders
WHERE EXTRACT(YEAR FROM order_date) = $1
GROUP BY EXTRACT(MONTH FROM order_date)
ORDER BY month
`

type GetMonthlyOrderCountsRow struct {
	Month      string `json:"month"`
	OrderCount int64  `json:"order_count"`
}

// Gets order counts by month for a given year
func (q *Queries) GetMonthlyOrderCounts(ctx context.Context, orderDate sql.NullTime) ([]GetMonthlyOrderCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyOrderCounts, orderDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonthlyOrderCountsRow{}
	for rows.Next() {
		var i GetMonthlyOrderCountsRow
		if err := rows.Scan(&i.Month, &i.OrderCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrder = `-- name: GetOrder :one
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
WHERE order_id = $1
`

// Gets an order by ID
func (q *Queries) GetOrder(ctx context.Context, orderID int16) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.OrderDate,
		&i.RequiredDate,
		&i.ShippedDate,
		&i.ShipVia,
		&i.Freight,
		&i.ShipName,
		&i.ShipAddress,
		&i.ShipCity,
		&i.ShipRegion,
		&i.ShipPostalCode,
		&i.ShipCountry,
	)
	return i, err
}

const getOrderWithDetails = `-- name: GetOrderWithDetails :one
SELECT 
  o.order_id, o.customer_id, o.employee_id, o.order_date, o.required_date, o.shipped_date, o.ship_via, o.freight, o.ship_name, o.ship_address, o.ship_city, o.ship_region, o.ship_postal_code, o.ship_country,
  c.company_name as customer_name,
  c.contact_name as customer_contact,
  CONCAT(e.first_name, ' ', e.last_name) as employee_name,
  s.company_name as shipper_name
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
LEFT JOIN employees e ON o.employee_id = e.employee_id
LEFT JOIN shippers s ON o.ship_via = s.shipper_id
WHERE o.order_id = $1
`

type GetOrderWithDetailsRow struct {
	OrderID         int16           `json:"order_id"`
	CustomerID      interface{}     `json:"customer_id"`
	EmployeeID      sql.NullInt16   `json:"employee_id"`
	OrderDate       sql.NullTime    `json:"order_date"`
	RequiredDate    sql.NullTime    `json:"required_date"`
	ShippedDate     sql.NullTime    `json:"shipped_date"`
	ShipVia         sql.NullInt16   `json:"ship_via"`
	Freight         sql.NullFloat64 `json:"freight"`
	ShipName        sql.NullString  `json:"ship_name"`
	ShipAddress     sql.NullString  `json:"ship_address"`
	ShipCity        sql.NullString  `json:"ship_city"`
	ShipRegion      sql.NullString  `json:"ship_region"`
	ShipPostalCode  sql.NullString  `json:"ship_postal_code"`
	ShipCountry     sql.NullString  `json:"ship_country"`
	CustomerName    sql.NullString  `json:"customer_name"`
	CustomerContact sql.NullString  `json:"customer_contact"`
	EmployeeName    interface{}     `json:"employee_name"`
	ShipperName     sql.NullString  `json:"shipper_name"`
}

// Gets an order by ID with customer, employee, and shipper details
func (q *Queries) GetOrderWithDetails(ctx context.Context, orderID int16) (GetOrderWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getOrderWithDetails, orderID)
	var i GetOrderWithDetailsRow
	err := row.Scan(
		&i.OrderID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.OrderDate,
		&i.RequiredDate,
		&i.ShippedDate,
		&i.ShipVia,
		&i.Freight,
		&i.ShipName,
		&i.ShipAddress,
		&i.ShipCity,
		&i.ShipRegion,
		&i.ShipPostalCode,
		&i.ShipCountry,
		&i.CustomerName,
		&i.CustomerContact,
		&i.EmployeeName,
		&i.ShipperName,
	)
	return i, err
}

const getTotalFreightByCustomer = `-- name: GetTotalFreightByCustomer :many
SELECT
  o.customer_id,
  c.company_name,
  SUM(o.freight) as total_freight
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
GROUP BY o.customer_id, c.company_name
ORDER BY SUM(o.freight) DESC
LIMIT $1
`

type GetTotalFreightByCustomerRow struct {
	CustomerID   interface{} `json:"customer_id"`
	CompanyName  string      `json:"company_name"`
	TotalFreight int64       `json:"total_freight"`
}

// Gets total freight costs grouped by customer
func (q *Queries) GetTotalFreightByCustomer(ctx context.Context, limit int32) ([]GetTotalFreightByCustomerRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalFreightByCustomer, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTotalFreightByCustomerRow{}
	for rows.Next() {
		var i GetTotalFreightByCustomerRow
		if err := rows.Scan(&i.CustomerID, &i.CompanyName, &i.TotalFreight); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDelayedOrders = `-- name: ListDelayedOrders :many
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
WHERE shipped_date > required_date
ORDER BY shipped_date DESC
`

// Lists orders that were shipped after the required date
func (q *Queries) ListDelayedOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listDelayedOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.OrderDate,
			&i.RequiredDate,
			&i.ShippedDate,
			&i.ShipVia,
			&i.Freight,
			&i.ShipName,
			&i.ShipAddress,
			&i.ShipCity,
			&i.ShipRegion,
			&i.ShipPostalCode,
			&i.ShipCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
ORDER BY order_date DESC
`

// Lists all orders sorted by date (newest first)
func (q *Queries) ListOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.OrderDate,
			&i.RequiredDate,
			&i.ShippedDate,
			&i.ShipVia,
			&i.Freight,
			&i.ShipName,
			&i.ShipAddress,
			&i.ShipCity,
			&i.ShipRegion,
			&i.ShipPostalCode,
			&i.ShipCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByCustomer = `-- name: ListOrdersByCustomer :many
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
WHERE customer_id = $1
ORDER BY order_date DESC
`

// Lists all orders for a specific customer
func (q *Queries) ListOrdersByCustomer(ctx context.Context, customerID interface{}) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.OrderDate,
			&i.RequiredDate,
			&i.ShippedDate,
			&i.ShipVia,
			&i.Freight,
			&i.ShipName,
			&i.ShipAddress,
			&i.ShipCity,
			&i.ShipRegion,
			&i.ShipPostalCode,
			&i.ShipCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByDateRange = `-- name: ListOrdersByDateRange :many
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
WHERE order_date BETWEEN $1 AND $2
ORDER BY order_date DESC
`

type ListOrdersByDateRangeParams struct {
	OrderDate   sql.NullTime `json:"order_date"`
	OrderDate_2 sql.NullTime `json:"order_date_2"`
}

// Lists orders within a specific date range
func (q *Queries) ListOrdersByDateRange(ctx context.Context, arg ListOrdersByDateRangeParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByDateRange, arg.OrderDate, arg.OrderDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.OrderDate,
			&i.RequiredDate,
			&i.ShippedDate,
			&i.ShipVia,
			&i.Freight,
			&i.ShipName,
			&i.ShipAddress,
			&i.ShipCity,
			&i.ShipRegion,
			&i.ShipPostalCode,
			&i.ShipCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByEmployee = `-- name: ListOrdersByEmployee :many
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
WHERE employee_id = $1
ORDER BY order_date DESC
`

// Lists all orders handled by a specific employee
func (q *Queries) ListOrdersByEmployee(ctx context.Context, employeeID sql.NullInt16) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.OrderDate,
			&i.RequiredDate,
			&i.ShippedDate,
			&i.ShipVia,
			&i.Freight,
			&i.ShipName,
			&i.ShipAddress,
			&i.ShipCity,
			&i.ShipRegion,
			&i.ShipPostalCode,
			&i.ShipCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByShipper = `-- name: ListOrdersByShipper :many
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
WHERE ship_via = $1
ORDER BY order_date DESC
`

// Lists all orders shipped by a specific shipper
func (q *Queries) ListOrdersByShipper(ctx context.Context, shipVia sql.NullInt16) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByShipper, shipVia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.OrderDate,
			&i.RequiredDate,
			&i.ShippedDate,
			&i.ShipVia,
			&i.Freight,
			&i.ShipName,
			&i.ShipAddress,
			&i.ShipCity,
			&i.ShipRegion,
			&i.ShipPostalCode,
			&i.ShipCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingShipments = `-- name: ListPendingShipments :many
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
WHERE shipped_date IS NULL
ORDER BY required_date ASC
`

// Lists orders that have not been shipped yet
func (q *Queries) ListPendingShipments(ctx context.Context) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listPendingShipments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.OrderDate,
			&i.RequiredDate,
			&i.ShippedDate,
			&i.ShipVia,
			&i.Freight,
			&i.ShipName,
			&i.ShipAddress,
			&i.ShipCity,
			&i.ShipRegion,
			&i.ShipPostalCode,
			&i.ShipCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentOrders = `-- name: ListRecentOrders :many
SELECT order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
FROM orders
WHERE order_date >= CURRENT_DATE - $1::interval
ORDER BY order_date DESC
`

// Lists orders placed within a specified number of days
func (q *Queries) ListRecentOrders(ctx context.Context, dollar_1 int64) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listRecentOrders, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.OrderDate,
			&i.RequiredDate,
			&i.ShippedDate,
			&i.ShipVia,
			&i.Freight,
			&i.ShipName,
			&i.ShipAddress,
			&i.ShipCity,
			&i.ShipRegion,
			&i.ShipPostalCode,
			&i.ShipCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET
  customer_id = $2,
  employee_id = $3,
  order_date = $4,
  required_date = $5,
  shipped_date = $6,
  ship_via = $7,
  freight = $8,
  ship_name = $9,
  ship_address = $10,
  ship_city = $11,
  ship_region = $12,
  ship_postal_code = $13,
  ship_country = $14
WHERE order_id = $1
RETURNING order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
`

type UpdateOrderParams struct {
	OrderID        int16           `json:"order_id"`
	CustomerID     interface{}     `json:"customer_id"`
	EmployeeID     sql.NullInt16   `json:"employee_id"`
	OrderDate      sql.NullTime    `json:"order_date"`
	RequiredDate   sql.NullTime    `json:"required_date"`
	ShippedDate    sql.NullTime    `json:"shipped_date"`
	ShipVia        sql.NullInt16   `json:"ship_via"`
	Freight        sql.NullFloat64 `json:"freight"`
	ShipName       sql.NullString  `json:"ship_name"`
	ShipAddress    sql.NullString  `json:"ship_address"`
	ShipCity       sql.NullString  `json:"ship_city"`
	ShipRegion     sql.NullString  `json:"ship_region"`
	ShipPostalCode sql.NullString  `json:"ship_postal_code"`
	ShipCountry    sql.NullString  `json:"ship_country"`
}

// Updates an order by ID
func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrder,
		arg.OrderID,
		arg.CustomerID,
		arg.EmployeeID,
		arg.OrderDate,
		arg.RequiredDate,
		arg.ShippedDate,
		arg.ShipVia,
		arg.Freight,
		arg.ShipName,
		arg.ShipAddress,
		arg.ShipCity,
		arg.ShipRegion,
		arg.ShipPostalCode,
		arg.ShipCountry,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.OrderDate,
		&i.RequiredDate,
		&i.ShippedDate,
		&i.ShipVia,
		&i.Freight,
		&i.ShipName,
		&i.ShipAddress,
		&i.ShipCity,
		&i.ShipRegion,
		&i.ShipPostalCode,
		&i.ShipCountry,
	)
	return i, err
}

const updateShippingInfo = `-- name: UpdateShippingInfo :one
UPDATE orders
SET
  shipped_date = $2,
  ship_via = $3,
  freight = $4
WHERE order_id = $1
RETURNING order_id, customer_id, employee_id, order_date, required_date, shipped_date, ship_via, freight, ship_name, ship_address, ship_city, ship_region, ship_postal_code, ship_country
`

type UpdateShippingInfoParams struct {
	OrderID     int16           `json:"order_id"`
	ShippedDate sql.NullTime    `json:"shipped_date"`
	ShipVia     sql.NullInt16   `json:"ship_via"`
	Freight     sql.NullFloat64 `json:"freight"`
}

// Updates just the shipping info for an order
func (q *Queries) UpdateShippingInfo(ctx context.Context, arg UpdateShippingInfoParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateShippingInfo,
		arg.OrderID,
		arg.ShippedDate,
		arg.ShipVia,
		arg.Freight,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.OrderDate,
		&i.RequiredDate,
		&i.ShippedDate,
		&i.ShipVia,
		&i.Freight,
		&i.ShipName,
		&i.ShipAddress,
		&i.ShipCity,
		&i.ShipRegion,
		&i.ShipPostalCode,
		&i.ShipCountry,
	)
	return i, err
}
