// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: employee_territory.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEmployeesByTerritory = `-- name: CountEmployeesByTerritory :many
SELECT 
  t.territory_id,
  t.territory_description,
  COUNT(*) as employee_count
FROM employee_territories et
JOIN territories t ON et.territory_id = t.territory_id
GROUP BY t.territory_id, t.territory_description
ORDER BY COUNT(*) DESC
`

type CountEmployeesByTerritoryRow struct {
	TerritoryID          string      `json:"territory_id"`
	TerritoryDescription interface{} `json:"territory_description"`
	EmployeeCount        int64       `json:"employee_count"`
}

// Counts employees grouped by territory
func (q *Queries) CountEmployeesByTerritory(ctx context.Context) ([]CountEmployeesByTerritoryRow, error) {
	rows, err := q.db.Query(ctx, countEmployeesByTerritory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountEmployeesByTerritoryRow{}
	for rows.Next() {
		var i CountEmployeesByTerritoryRow
		if err := rows.Scan(&i.TerritoryID, &i.TerritoryDescription, &i.EmployeeCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countTerritoriesByEmployee = `-- name: CountTerritoriesByEmployee :many
SELECT 
  e.employee_id,
  e.first_name,
  e.last_name,
  COUNT(*) as territory_count
FROM employee_territories et
JOIN employees e ON et.employee_id = e.employee_id
GROUP BY e.employee_id, e.first_name, e.last_name
ORDER BY COUNT(*) DESC
`

type CountTerritoriesByEmployeeRow struct {
	EmployeeID     int16  `json:"employee_id"`
	FirstName      string `json:"first_name"`
	LastName       string `json:"last_name"`
	TerritoryCount int64  `json:"territory_count"`
}

// Counts territories grouped by employee
func (q *Queries) CountTerritoriesByEmployee(ctx context.Context) ([]CountTerritoriesByEmployeeRow, error) {
	rows, err := q.db.Query(ctx, countTerritoriesByEmployee)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountTerritoriesByEmployeeRow{}
	for rows.Next() {
		var i CountTerritoriesByEmployeeRow
		if err := rows.Scan(
			&i.EmployeeID,
			&i.FirstName,
			&i.LastName,
			&i.TerritoryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createEmployeeTerritoryRelation = `-- name: CreateEmployeeTerritoryRelation :one
INSERT INTO employee_territories (
  employee_id,
  territory_id
) VALUES (
  $1, $2
)
RETURNING employee_id, territory_id
`

type CreateEmployeeTerritoryRelationParams struct {
	EmployeeID  int16  `json:"employee_id"`
	TerritoryID string `json:"territory_id"`
}

// Assigns a territory to an employee
func (q *Queries) CreateEmployeeTerritoryRelation(ctx context.Context, arg CreateEmployeeTerritoryRelationParams) (EmployeeTerritory, error) {
	row := q.db.QueryRow(ctx, createEmployeeTerritoryRelation, arg.EmployeeID, arg.TerritoryID)
	var i EmployeeTerritory
	err := row.Scan(&i.EmployeeID, &i.TerritoryID)
	return i, err
}

const deleteAllEmployeeAssignmentsForTerritory = `-- name: DeleteAllEmployeeAssignmentsForTerritory :exec
DELETE FROM employee_territories
WHERE territory_id = $1
`

// Removes all employee assignments for a specific territory
func (q *Queries) DeleteAllEmployeeAssignmentsForTerritory(ctx context.Context, territoryID string) error {
	_, err := q.db.Exec(ctx, deleteAllEmployeeAssignmentsForTerritory, territoryID)
	return err
}

const deleteAllTerritoryAssignmentsForEmployee = `-- name: DeleteAllTerritoryAssignmentsForEmployee :exec
DELETE FROM employee_territories
WHERE employee_id = $1
`

// Removes all territory assignments for a specific employee
func (q *Queries) DeleteAllTerritoryAssignmentsForEmployee(ctx context.Context, employeeID int16) error {
	_, err := q.db.Exec(ctx, deleteAllTerritoryAssignmentsForEmployee, employeeID)
	return err
}

const deleteEmployeeTerritoryRelation = `-- name: DeleteEmployeeTerritoryRelation :exec
DELETE FROM employee_territories
WHERE employee_id = $1 AND territory_id = $2
`

type DeleteEmployeeTerritoryRelationParams struct {
	EmployeeID  int16  `json:"employee_id"`
	TerritoryID string `json:"territory_id"`
}

// Removes a specific territory assignment from an employee
func (q *Queries) DeleteEmployeeTerritoryRelation(ctx context.Context, arg DeleteEmployeeTerritoryRelationParams) error {
	_, err := q.db.Exec(ctx, deleteEmployeeTerritoryRelation, arg.EmployeeID, arg.TerritoryID)
	return err
}

const getEmployeeTerritoryRelation = `-- name: GetEmployeeTerritoryRelation :one
SELECT employee_id, territory_id
FROM employee_territories
WHERE employee_id = $1 AND territory_id = $2
`

type GetEmployeeTerritoryRelationParams struct {
	EmployeeID  int16  `json:"employee_id"`
	TerritoryID string `json:"territory_id"`
}

// Gets a specific employee-territory relation
func (q *Queries) GetEmployeeTerritoryRelation(ctx context.Context, arg GetEmployeeTerritoryRelationParams) (EmployeeTerritory, error) {
	row := q.db.QueryRow(ctx, getEmployeeTerritoryRelation, arg.EmployeeID, arg.TerritoryID)
	var i EmployeeTerritory
	err := row.Scan(&i.EmployeeID, &i.TerritoryID)
	return i, err
}

const listEmployeesByRegion = `-- name: ListEmployeesByRegion :many
SELECT DISTINCT
  e.employee_id,
  e.first_name,
  e.last_name,
  e.title
FROM employee_territories et
JOIN territories t ON et.territory_id = t.territory_id
JOIN employees e ON et.employee_id = e.employee_id
WHERE t.region_id = $1
ORDER BY e.last_name, e.first_name
`

type ListEmployeesByRegionRow struct {
	EmployeeID int16       `json:"employee_id"`
	FirstName  string      `json:"first_name"`
	LastName   string      `json:"last_name"`
	Title      pgtype.Text `json:"title"`
}

// Lists employees assigned to territories in a specific region
func (q *Queries) ListEmployeesByRegion(ctx context.Context, regionID int16) ([]ListEmployeesByRegionRow, error) {
	rows, err := q.db.Query(ctx, listEmployeesByRegion, regionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeesByRegionRow{}
	for rows.Next() {
		var i ListEmployeesByRegionRow
		if err := rows.Scan(
			&i.EmployeeID,
			&i.FirstName,
			&i.LastName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesByTerritory = `-- name: ListEmployeesByTerritory :many
SELECT e.employee_id, e.last_name, e.first_name, e.title, e.title_of_courtesy, e.birth_date, e.hire_date, e.address, e.city, e.region, e.postal_code, e.country, e.home_phone, e.extension, e.photo, e.notes, e.reports_to, e.photo_path
FROM employee_territories et
JOIN employees e ON et.employee_id = e.employee_id
WHERE et.territory_id = $1
ORDER BY e.last_name, e.first_name
`

// Lists all employees assigned to a specific territory
func (q *Queries) ListEmployeesByTerritory(ctx context.Context, territoryID string) ([]Employee, error) {
	rows, err := q.db.Query(ctx, listEmployeesByTerritory, territoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmployeeID,
			&i.LastName,
			&i.FirstName,
			&i.Title,
			&i.TitleOfCourtesy,
			&i.BirthDate,
			&i.HireDate,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.HomePhone,
			&i.Extension,
			&i.Photo,
			&i.Notes,
			&i.ReportsTo,
			&i.PhotoPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesWithTerritoriesAndRegions = `-- name: ListEmployeesWithTerritoriesAndRegions :many
SELECT 
  e.employee_id,
  e.first_name,
  e.last_name,
  t.territory_id,
  t.territory_description,
  r.region_id,
  r.region_description
FROM employee_territories et
JOIN employees e ON et.employee_id = e.employee_id
JOIN territories t ON et.territory_id = t.territory_id
JOIN region r ON t.region_id = r.region_id
ORDER BY e.last_name, e.first_name, r.region_id, t.territory_id
`

type ListEmployeesWithTerritoriesAndRegionsRow struct {
	EmployeeID           int16       `json:"employee_id"`
	FirstName            string      `json:"first_name"`
	LastName             string      `json:"last_name"`
	TerritoryID          string      `json:"territory_id"`
	TerritoryDescription interface{} `json:"territory_description"`
	RegionID             int16       `json:"region_id"`
	RegionDescription    interface{} `json:"region_description"`
}

// Lists employees with their territories and regions
func (q *Queries) ListEmployeesWithTerritoriesAndRegions(ctx context.Context) ([]ListEmployeesWithTerritoriesAndRegionsRow, error) {
	rows, err := q.db.Query(ctx, listEmployeesWithTerritoriesAndRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeesWithTerritoriesAndRegionsRow{}
	for rows.Next() {
		var i ListEmployeesWithTerritoriesAndRegionsRow
		if err := rows.Scan(
			&i.EmployeeID,
			&i.FirstName,
			&i.LastName,
			&i.TerritoryID,
			&i.TerritoryDescription,
			&i.RegionID,
			&i.RegionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTerritoriesByEmployee = `-- name: ListTerritoriesByEmployee :many
SELECT t.territory_id, t.territory_description, t.region_id
FROM employee_territories et
JOIN territories t ON et.territory_id = t.territory_id
WHERE et.employee_id = $1
ORDER BY t.territory_id
`

// Lists all territories assigned to a specific employee
func (q *Queries) ListTerritoriesByEmployee(ctx context.Context, employeeID int16) ([]Territory, error) {
	rows, err := q.db.Query(ctx, listTerritoriesByEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Territory{}
	for rows.Next() {
		var i Territory
		if err := rows.Scan(&i.TerritoryID, &i.TerritoryDescription, &i.RegionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
