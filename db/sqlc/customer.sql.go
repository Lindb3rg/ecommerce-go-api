// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: customer.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllCustomers = `-- name: CountAllCustomers :one
SELECT COUNT(*) FROM customers
`

// Counts the total number of customers
func (q *Queries) CountAllCustomers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllCustomers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCustomersByCountry = `-- name: CountCustomersByCountry :many
SELECT country, COUNT(*) as customer_count
FROM customers
GROUP BY country
ORDER BY COUNT(*) DESC
`

type CountCustomersByCountryRow struct {
	Country       pgtype.Text `json:"country"`
	CustomerCount int64       `json:"customer_count"`
}

// Counts customers grouped by country
func (q *Queries) CountCustomersByCountry(ctx context.Context) ([]CountCustomersByCountryRow, error) {
	rows, err := q.db.Query(ctx, countCustomersByCountry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountCustomersByCountryRow{}
	for rows.Next() {
		var i CountCustomersByCountryRow
		if err := rows.Scan(&i.Country, &i.CustomerCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
  customer_id,
  company_name,
  contact_name,
  contact_title,
  address,
  city,
  region,
  postal_code,
  country,
  phone,
  fax
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
`

type CreateCustomerParams struct {
	CustomerID   interface{} `json:"customer_id"`
	CompanyName  string      `json:"company_name"`
	ContactName  pgtype.Text `json:"contact_name"`
	ContactTitle pgtype.Text `json:"contact_title"`
	Address      pgtype.Text `json:"address"`
	City         pgtype.Text `json:"city"`
	Region       pgtype.Text `json:"region"`
	PostalCode   pgtype.Text `json:"postal_code"`
	Country      pgtype.Text `json:"country"`
	Phone        pgtype.Text `json:"phone"`
	Fax          pgtype.Text `json:"fax"`
}

// Creates a new customer and returns it
func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.CustomerID,
		arg.CompanyName,
		arg.ContactName,
		arg.ContactTitle,
		arg.Address,
		arg.City,
		arg.Region,
		arg.PostalCode,
		arg.Country,
		arg.Phone,
		arg.Fax,
	)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.CompanyName,
		&i.ContactName,
		&i.ContactTitle,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Fax,
		&i.CreatedAt,
		&i.Active,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers
WHERE customer_id = $1
`

// OBS! Completely deletes a customer by customer_id
func (q *Queries) DeleteCustomer(ctx context.Context, customerID interface{}) error {
	_, err := q.db.Exec(ctx, deleteCustomer, customerID)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
FROM customers
WHERE customer_id = $1
`

// Gets a customer by ID
func (q *Queries) GetCustomer(ctx context.Context, customerID interface{}) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, customerID)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.CompanyName,
		&i.ContactName,
		&i.ContactTitle,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Fax,
		&i.CreatedAt,
		&i.Active,
	)
	return i, err
}

const listCustomers = `-- name: ListCustomers :many
SELECT customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
FROM customers
ORDER BY company_name
LIMIT $1 OFFSET $2
`

type ListCustomersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Lists all customers
func (q *Queries) ListCustomers(ctx context.Context, arg ListCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.CustomerID,
			&i.CompanyName,
			&i.ContactName,
			&i.ContactTitle,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
			&i.Fax,
			&i.CreatedAt,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomersByCity = `-- name: ListCustomersByCity :many
SELECT customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
FROM customers
WHERE city = $1
ORDER BY company_name
`

// Lists all customers from a specific city
func (q *Queries) ListCustomersByCity(ctx context.Context, city pgtype.Text) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listCustomersByCity, city)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.CustomerID,
			&i.CompanyName,
			&i.ContactName,
			&i.ContactTitle,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
			&i.Fax,
			&i.CreatedAt,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomersByCountry = `-- name: ListCustomersByCountry :many
SELECT customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
FROM customers
WHERE country = $1
ORDER BY company_name
`

// Lists all customers from a specific country
func (q *Queries) ListCustomersByCountry(ctx context.Context, country pgtype.Text) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listCustomersByCountry, country)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.CustomerID,
			&i.CompanyName,
			&i.ContactName,
			&i.ContactTitle,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
			&i.Fax,
			&i.CreatedAt,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctCountries = `-- name: ListDistinctCountries :many
SELECT DISTINCT country
FROM customers
WHERE country IS NOT NULL
ORDER BY country
`

// Returns all distinct countries in the customers table
func (q *Queries) ListDistinctCountries(ctx context.Context) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listDistinctCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Text{}
	for rows.Next() {
		var country pgtype.Text
		if err := rows.Scan(&country); err != nil {
			return nil, err
		}
		items = append(items, country)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomersByCompanyName = `-- name: SearchCustomersByCompanyName :many
SELECT customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
FROM customers
WHERE company_name ILIKE '%' || $1 || '%'
ORDER BY company_name
`

// Searches customers by company name (case insensitive)
func (q *Queries) SearchCustomersByCompanyName(ctx context.Context, dollar_1 pgtype.Text) ([]Customer, error) {
	rows, err := q.db.Query(ctx, searchCustomersByCompanyName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.CustomerID,
			&i.CompanyName,
			&i.ContactName,
			&i.ContactTitle,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
			&i.Fax,
			&i.CreatedAt,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomersByContactName = `-- name: SearchCustomersByContactName :many
SELECT customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
FROM customers
WHERE contact_name ILIKE '%' || $1 || '%'
ORDER BY contact_name
`

// Searches customers by contact name (case insensitive)
func (q *Queries) SearchCustomersByContactName(ctx context.Context, dollar_1 pgtype.Text) ([]Customer, error) {
	rows, err := q.db.Query(ctx, searchCustomersByContactName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.CustomerID,
			&i.CompanyName,
			&i.ContactName,
			&i.ContactTitle,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
			&i.Fax,
			&i.CreatedAt,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleCustomerActiveStatus = `-- name: ToggleCustomerActiveStatus :one
UPDATE customers
SET active = NOT active
WHERE customer_id = $1
RETURNING customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
`

// Toggles the active status of a customer by ID
func (q *Queries) ToggleCustomerActiveStatus(ctx context.Context, customerID interface{}) (Customer, error) {
	row := q.db.QueryRow(ctx, toggleCustomerActiveStatus, customerID)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.CompanyName,
		&i.ContactName,
		&i.ContactTitle,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Fax,
		&i.CreatedAt,
		&i.Active,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers
SET
  company_name = COALESCE($2, company_name),
  contact_name = COALESCE($3, contact_name),
  contact_title = COALESCE($4, contact_title),
  address = COALESCE($5, address),
  city = COALESCE($6, city),
  region = COALESCE($7, region),
  postal_code = COALESCE($8, postal_code),
  country = COALESCE($9, country),
  phone = COALESCE($10, phone),
  fax = COALESCE($11, fax)
WHERE customer_id = $1
RETURNING customer_id, company_name, contact_name, contact_title, address, city, region, postal_code, country, phone, fax, created_at, active
`

type UpdateCustomerParams struct {
	CustomerID   interface{} `json:"customer_id"`
	CompanyName  string      `json:"company_name"`
	ContactName  pgtype.Text `json:"contact_name"`
	ContactTitle pgtype.Text `json:"contact_title"`
	Address      pgtype.Text `json:"address"`
	City         pgtype.Text `json:"city"`
	Region       pgtype.Text `json:"region"`
	PostalCode   pgtype.Text `json:"postal_code"`
	Country      pgtype.Text `json:"country"`
	Phone        pgtype.Text `json:"phone"`
	Fax          pgtype.Text `json:"fax"`
}

// Updates specified columns for a customer, leaves others unchanged
func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomer,
		arg.CustomerID,
		arg.CompanyName,
		arg.ContactName,
		arg.ContactTitle,
		arg.Address,
		arg.City,
		arg.Region,
		arg.PostalCode,
		arg.Country,
		arg.Phone,
		arg.Fax,
	)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.CompanyName,
		&i.ContactName,
		&i.ContactTitle,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Fax,
		&i.CreatedAt,
		&i.Active,
	)
	return i, err
}
